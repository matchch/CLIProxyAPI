name: upstream-sync

on:
  schedule:
    - cron: "0 2 * * *"
  workflow_dispatch:

permissions:
  contents: write

env:
  UPSTREAM_REPO: router-for-me/CLIProxyAPI
  TARGET_BRANCH: ${{ github.event.repository.default_branch }}

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Configure push authentication
        env:
          WORKFLOW_TRIGGER_TOKEN: ${{ secrets.WORKFLOW_TRIGGER_TOKEN }}
        run: |
          set -euo pipefail
          if [ -n "${WORKFLOW_TRIGGER_TOKEN:-}" ]; then
            git remote set-url origin "https://x-access-token:${WORKFLOW_TRIGGER_TOKEN}@github.com/${GITHUB_REPOSITORY}.git"
            echo "Using WORKFLOW_TRIGGER_TOKEN for pushes."
          else
            echo "WORKFLOW_TRIGGER_TOKEN not set; fallback to default GITHUB_TOKEN checkout credentials."
          fi

      - name: Add upstream remote
        run: git remote add upstream https://github.com/${{ env.UPSTREAM_REPO }}.git

      - name: Resolve latest upstream release tag
        id: resolve_release
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail

          api_url="https://api.github.com/repos/${UPSTREAM_REPO}/releases?per_page=1"
          release_tag="$(
            curl -fsSL \
              -H "Authorization: Bearer ${GH_TOKEN}" \
              -H "Accept: application/vnd.github+json" \
              "${api_url}" \
              | python3 -c 'import json,sys; data=json.load(sys.stdin); print(data[0].get("tag_name", "") if data else "")'
          )"

          if [ -z "${release_tag}" ] || [ "${release_tag}" = "null" ]; then
            echo "No upstream release tag found."
            echo "has_new_release=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if git ls-remote --exit-code --tags origin "refs/tags/${release_tag}" >/dev/null 2>&1; then
            echo "Release tag already exists in origin: ${release_tag}"
            echo "has_new_release=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "Detected new upstream release tag: ${release_tag}"
          echo "upstream_release_tag=${release_tag}" >> "$GITHUB_OUTPUT"
          echo "has_new_release=true" >> "$GITHUB_OUTPUT"

      - name: Fetch upstream branch and release tag
        if: steps.resolve_release.outputs.has_new_release == 'true'
        run: |
          set -euo pipefail
          git fetch upstream --no-tags "${TARGET_BRANCH}:refs/remotes/upstream/${TARGET_BRANCH}"
          git fetch upstream "refs/tags/${{ steps.resolve_release.outputs.upstream_release_tag }}:refs/tags/${{ steps.resolve_release.outputs.upstream_release_tag }}"

      - name: Sync default branch
        if: steps.resolve_release.outputs.has_new_release == 'true'
        env:
          BRANCH_NAME: ${{ env.TARGET_BRANCH }}
        run: |
          set -euo pipefail
          branch="${BRANCH_NAME:-${GITHUB_REF_NAME:-main}}"
          git checkout "$branch"
          # Keep commit history linear by replaying local commits on top of upstream.
          git rebase "upstream/${branch}"
          # Rebase rewrites commit history, so update remote with a safe force push.
          git push --force-with-lease origin "$branch"

      - name: Push release tag to origin
        if: steps.resolve_release.outputs.has_new_release == 'true'
        run: |
          set -euo pipefail
          git push origin "refs/tags/${{ steps.resolve_release.outputs.upstream_release_tag }}"
